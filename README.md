# Solution for Recruitment Assigment

## Executing the code

### Building
The code is configured to be build using colcon. Run
    colcon build

in the `ros2_ws` folder.

### Running
Use 

    . install/setup.bash
    ros2 launch environment simulation.launch.py

in the `ros2_ws` folder to run the code.
Configuration is done using the `environment.yaml` in the `config`folder of the `environment` package.
For deciding which robot should be used during simulation comment the other line in the `simulation.launch.py` file as shown below:

    #model_path = os.path.join(pkg_share, 'models/robot_1.urdf')
    model_path = os.path.join(pkg_share, 'models/robot_2.urdf')


### Testing
The code was tested on an Ubuntu 22.04 LTS version running ros2 humble.

## Documentation
### General information

The complete code does not use any libraries for simulation and control. Therefore some solutions may not be the most ideal or direct way to tacle the specific problem. My approach was rather to build a flexible and adaptable environment which can be easiliy configured and is flexible to adapt to different conditions. The whole assignment could have bin done using the ros2 navigation2 package by building up a config file and an environment in Gazebo and is in most cases a more reliable way to achieve a good solution, however its scope exceeds the scope of the assignment significantly which is the reason why a small and simple controller based on an artificial potential field was used to generate these results. The robots are visualized using 2 `URDF`-files where the origin is the center of the robot.

### Packages

The software consists of 4 packages
    - environment
    - controller
    - odom
    - obstacle

The `obstacle`-package consists only of a header defining the `Obstacle` class and generated the custom message types `Obstacle.msg` and `ObstacleArray.msg`. The `odom`-package integrates the `geopmetry_msgs::msg::Twist velocitiy`-messages generated by the controller, integrates them and publishes transforms and `geometry_msgs::msg::Pose odom` for the localization. The `environment`-package generates the desired environment, publishes `obstacles`-messages and generates also the initial position of the robots. The `controller`-package receives `obstacles`- and`odom`-messages to generate a velocity in which the robot has to move to reach the target position.

![rqt_graph](/img/rqt_graph.png)

### Configuration
#### Environment (map_generator)

The obstacles are generated randomly in the range of `(-map_dimension/2, map_dimension/2)` using an uniform distribution. To guarantee that there is enough space to fit through to obstacles `min_obstacle_distance` in the config-file. The diameter and number of obstcales is configured using `obstacle_number`, `obstacle_radius`. The controller is configurable to lead to any location on the map using the `goal_position` parameter. To guarantee that obstacles have enough distance to the goal position, the parameter is loaded during the map generation and used for a distance comparison to all obstacles as well. To generate a T-floor plan `generate_T` has to be set to true. `width_T_center`, `width_T_top` and `length_T` is then used to configure the width and length of the different T-sections.
**Note:** It is recommended to set the source location as `goal_position` to guarantee enough distance to the random obstacles. To generate an environment without obstacles, `obstacle_number` has to be set to 0.

#### Controller (apf_controller)
The controller used is based on an *artificial potential field*. To heading computation can be ignored using the `ignore_heading` parameter. The maximum (rotational) velocity is set using `max_velocity` and `max_rot_speed_deg`. `robot_length` is necessary for the heading control and defines the length of the robot. `signma_source` configures the shape of the source function. As mentioned above `goal_position` is used to set the goal of the robot, however it will be ignored if `seek_source` is set to `true`.


    /map_generator:
        ros__parameters:
            map_dimension: 6.0
            min_obstacle_distance: 2.1
            generate_T: false
            width_T_center: 1.5
            width_T_top: 1.25
            length_T: 5.0
            obstacle_number: 4
            obstacle_diameter: 1.0

        
    /apf_controller:
        ros__parameters:
            ignore_heading: false
            max_vel: 5.0
            robot_length: 1.5
            sigma_source: 4.0
            max_rot_speed_deg: 120.0

    /**:
        ros__parameters:
            goal_position: [0.84, -0.2] #set source [0.84, -0.2] as goal to guarantee distance to obstacles
            seek_source: true

